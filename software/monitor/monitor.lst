# File ./monitor.asm
0000			; 2013-10-20: A simple but working ROM monitor program for the great Z80 system-on-FPGA project. 
0000			; This is my first Z80 assembler program so ... be kind. 
0000			 
0000			; Wishlist: 
0000			;    dm could print an extra space after 8th char, and chars in ASCII on the right hand side, a la hexdump -C 
0000			 
0000			; hardware register addresses 
0000			UART0_STATUS:  equ 0x00 ; [7: RX READY] [6: TX BUSY] [6 unused bits] 
0000			UART0_DATA:    equ 0x01 
0000			UART1_STATUS:  equ 0x28 
0000			UART1_DATA:    equ 0x29 
0000			STACK_INIT:    equ 0xF000 ; stack (grows downwards, runtime movable) 
0000			INPUT_BUFFER:  equ 0xEF00 ; input buffer (grows upwards, runtime movable) 
0000			 
0000			SPI_CHIPSELECT: equ 0x18 
0000			SPI_STATUS:     equ 0x19 
0000			SPI_TX:         equ 0x1a 
0000			SPI_RX:         equ 0x1b 
0000			SPI_DIVISOR:    equ 0x1c 
0000			GPIO_INPUT:     equ 0x20 
0000			GPIO_OUTPUT:    equ 0x21 
0000			 
0000			MMU_SELECT:    equ 0xF8   ; page table entry selector 
0000			MMU_PAGE17:    equ 0xFA   ; magic I/O port that accesses physical memory 
0000			MMU_PERM:      equ 0xFB   ; permission bits [6 unused bits] [WRITE] [READ] 
0000			MMU_FRAMEHI:   equ 0xFC   ; high byte of frame number 
0000			MMU_FRAMELO:   equ 0xFD   ; low byte of frame number 
0000			MMU_PTR_VAL0:  equ 0xFC 
0000			MMU_PTR_VAL1:  equ 0xFD 
0000			MMU_PTR_VAL2:  equ 0xFE 
0000			MMU_PTR_VAL3:  equ 0xFF 
0000			 
0000			FLASH_MAN:     equ 0xc2 
0000			FLASH_DEV1:    equ 0x20 
0000			FLASH_DEV2:    equ 0x17 
0000			 
0000			RAM_MB: equ 8 
0000			 
0000			        ; on reset, the MMU maps us at 0x0000 for 4K, 
0000			        ; however it's really useful to have access to this 
0000			        ; first page because it's where we can put programs 
0000			        ; for CP/M to run, etc. So we remap ourselves up to 
0000			        ; 0xf000 and run from there. 
0000			 
0000			        org 0x0000 ; early ROM location (also Z80 reset vector) 
0000			 
0000			        ; test if we're cold booting -- have to do this reasonably quickly, 
0000			        ; before the SDRAM controller has initialised itself (~0.1msec) 
0000 db 20		        in a, (GPIO_INPUT) 
0002 47			        ld b, a ; stash that for now 
0003			 
0003 f3			        di ; disable interrupts (for those arriving via RST 0 rather than CPU reset) 
0004			        ; map page at 0xF000 to 0x2000000 physical (4K SRAM ROM) 
0004 3e 0f		        ld a, 0xf 
0006 d3 f8		        out (MMU_SELECT), a 
0008 3e 20		        ld a, 0x20 
000a d3 fc		        out (MMU_FRAMEHI), a 
000c af			        xor a 
000d d3 fd		        out (MMU_FRAMELO), a 
000f 3e 03		        ld a, 0x03 
0011 d3 fb		        out (MMU_PERM), a 
0013			        ; jump to monitor in new location 
0013 c3 16 f0		        jp boot 
0016			        org 0xF000 + $ 
f016			boot: 
f016			        ; use MMU to map SDRAM into page 0 
f016 af			        xor a 
f017 d3 f8		        out (MMU_SELECT), a 
f019 d3 fc		        out (MMU_FRAMEHI), a 
f01b d3 fd		        out (MMU_FRAMELO), a 
f01d 3e 03		        ld a, 0x03 ; map it read/write 
f01f d3 fb		        out (MMU_PERM), a 
f021			 
f021 78			        ld a, b ; recover the coldboot flag 
f022 e6 80		        and 0x80 ; had the SDRAM controller initialisation completed? 
f024 28 46		        jr z, warmboot ; yes! it's a warm boot then. 
f026			 
f026			        ; no; it's a cold boot 
f026 31 00 10		        ld sp, 0x1000 
f029			 
f029 21 1b f7		        ld hl, coldbootmsg 
f02c cd ff f5		        call outstring 
f02f			 
f02f			        ; we're going to zero out RAM, each 4K page in turn 
f02f 21 00 00		        ld hl, 0x0 
f032			 
f032			        ; use frame starting at 0x1000 
f032 3e 01		        ld a, 1 
f034 d3 f8		        out (MMU_SELECT), a 
f036 3e 03		        ld a, 0x03 
f038 d3 fb		        out (MMU_PERM), a 
f03a			 
f03a			        ; for each page ... 
f03a			cbnextpage: 
f03a			        ; map it in 
f03a 7c			        ld a, h 
f03b d3 fc		        out (MMU_FRAMEHI), a 
f03d d3 21		        out (GPIO_OUTPUT), a ; also display code on LEDs 
f03f 7d			        ld a, l 
f040 d3 fd		        out (MMU_FRAMELO), a 
f042 e5			        push hl ; stash page number 
f043			 
f043			        ; write zeroes to the 4K page mapped at 0x1000....0x1fff 
f043 21 00 10		        ld hl, 0x1000 
f046 11 01 10		        ld de, 0x1001 
f049 01 ff 0f		        ld bc, 0x0fff 
f04c 36 00		        ld (hl), 0 ; fill memory with with 0s 
f04e ed b0		        ldir 
f050			 
f050 e1			        pop hl ; recover page number (we overwrite it in cycle 0, but with 0s) 
f051 23			        inc hl 
f052 7d			        ld a, l 
f053 fe 00		        cp 0 
f055 20 e3		        jr nz, cbnextpage 
f057 7c			        ld a, h 
f058 cd 4b f6		        call outnibble       ; print char after each MB zeroed 
f05b 7c			        ld a, h 
f05c fe 08		        cp RAM_MB ; test if we're up to system RAM size? 
f05e 20 da		        jr nz, cbnextpage 
f060			 
f060 cd 16 f6		        call outnewline 
f063			 
f063			        ; turn off LEDs 
f063 af			        xor a 
f064 d3 21		        out (GPIO_OUTPUT), a 
f066			 
f066			        ; restore MMU config 
f066 af			        xor a 
f067 d3 fc		        out (MMU_FRAMEHI), a 
f069 3c			        inc a 
f06a d3 fd		        out (MMU_FRAMELO), a 
f06c			 
f06c			        ; fall through to warm boot process 
f06c			warmboot: 
f06c 31 00 f0		        ld sp, STACK_INIT   ; load stack pointer to point to 1 byte past top of memory 
f06f fd 21 00 ef	        ld iy, INPUT_BUFFER ; set default input buffer location 256 bytes below top of stack 
f073			 
f073			        ; put a reset vector in place to jump back into us 
f073 3e c3		        ld a, 0xc3 ; jmp instruction 
f075 32 00 00		        ld (0), a 
f078 21 16 f0		        ld hl, boot 
f07b 22 01 00		        ld (1), hl 
f07e			 
f07e			        ; turn off bright LEDs! 
f07e af			        xor a 
f07f d3 21		        out (GPIO_OUTPUT), a 
f081			 
f081			        ; print our greeting 
f081 21 35 f7		        ld hl, greeting 
f084 cd ff f5		        call outstring 
f087			 
f087			        ; flush UART FIFO 
f087			fifoflush: 
f087 db 01		        in a, (UART0_DATA)     ; read byte from UART 
f089 db 00		        in a, (UART0_STATUS)   ; check status 
f08b cb 7f		        bit 7, a               ; test if data waiting 
f08d 20 f8		        jr nz, fifoflush       ; keep flushing if there is 
f08f			 
f08f			monitor_loop: 
f08f 21 0b f8		        ld hl, monitor_prompt 
f092 cd ff f5		        call outstring 
f095			 
f095 fd e5		        push iy ; HL=IY 
f097 e1			        pop hl 
f098 cd 66 f6		        call instring 
f09b cd 16 f6		        call outnewline 
f09e			 
f09e dd 21 53 fd	        ld ix, cmd_table 
f0a2			testnextcmd: 
f0a2 fd e5		        push iy ; HL=IY 
f0a4 e1			        pop hl 
f0a5			        ; test for end of string 
f0a5 7e			        ld a, (hl) 
f0a6 fe 00		        cp 0 
f0a8 28 e5		        jr z, monitor_loop 
f0aa			        ; load string address 
f0aa dd 5e 00		        ld e, (ix+0) 
f0ad dd 56 01		        ld d, (ix+1) 
f0b0 cd f5 f5		        call cmdcompare 
f0b3 ca cd f0		        jp z, runcmd 
f0b6			        ; advance ix to point to next command 
f0b6 01 04 00		        ld bc, 4 
f0b9 dd 09		        add ix, bc 
f0bb			        ; list is terminated with a zero, check for that 
f0bb dd 7e 00		        ld a, (ix+0) 
f0be dd b6 01		        or (ix+1) 
f0c1 fe 00		        cp 0 
f0c3 20 dd		        jr nz, testnextcmd 
f0c5			        ; end of list but no command found 
f0c5 21 11 f8		        ld hl, what_msg 
f0c8 cd ff f5		        call outstring 
f0cb 18 c2		        jr monitor_loop 
f0cd			runcmd: ; run command at ix+2, ix+3 
f0cd dd 5e 02		        ld e, (ix+2) 
f0d0 dd 56 03		        ld d, (ix+3) 
f0d3 d5			        push de 
f0d4 dd e1		        pop ix 
f0d6 dd e9		        jp (ix) 
f0d8			 
f0d8			do_help: 
f0d8 21 36 fa		        ld hl, help_msg 
f0db cd ff f5		        call outstring 
f0de c3 8f f0		        jp monitor_loop 
f0e1			 
f0e1			; parse command line to display I/O register contents. call with (HL) pointing into input buffer after "in " 
f0e1			do_in: 
f0e1 cd e3 f6		        call skipspaces 
f0e4 cd f3 f6		        call parsehexorfail 
f0e7			        ; DE now contains the I/O address to read 
f0e7 d5			        push de 
f0e8 cd 33 f6		        call outde 
f0eb 3e 3d		        ld a, 0x3d 
f0ed cd 59 f6		        call outchar 
f0f0 3e 20		        ld a, 0x20 
f0f2 cd 59 f6		        call outchar 
f0f5 c1			        pop bc 
f0f6 ed 78		        in a, (c) ; asserts full 16-bit address bus 
f0f8 cd 3c f6		        call outcharhex 
f0fb cd 16 f6		        call outnewline 
f0fe cd e3 f6		        call skipspaces 
f101 7e			        ld a, (hl) 
f102 fe 00		        cp 0 
f104 ca 8f f0		        jp z, monitor_loop  ; don't use ret, we get here by a jump and not a call. 
f107 18 d8		        jr do_in  ; next address 
f109			 
f109			; write to I/O register 
f109			do_out: 
f109 cd e3 f6		        call skipspaces 
f10c cd f3 f6		        call parsehexorfail 
f10f			        ; DE now contains the I/O address 
f10f d5			        push de 
f110			nextio: 
f110 cd e3 f6		        call skipspaces 
f113 cd f3 f6		        call parsehexorfail 
f116			        ; DE now contains the value to write 
f116 7a			        ld a, d ; check D=0 
f117 fe 00		        cp 0 
f119 20 31		        jr nz, invalid 
f11b c1			        pop bc ; I/O address 
f11c ed 59		        out (c), e 
f11e 03			        inc bc ; next I/O address 
f11f cd e3 f6		        call skipspaces 
f122 7e			        ld a, (hl) 
f123 fe 00		        cp 0 
f125 ca 8f f0		        jp z, monitor_loop 
f128 c5			        push bc 
f129 18 e5		        jr nextio 
f12b			 
f12b			; write to memory command 
f12b			do_wm: 
f12b cd e3 f6		        call skipspaces 
f12e cd f3 f6		        call parsehexorfail 
f131 d5			        push de 
f132 dd e1		        pop ix    ; put the memory address in ix 
f134			wm_nextbyte: 
f134 cd e3 f6		        call skipspaces 
f137 7e			        ld a, (hl) 
f138 fe 00		        cp 0 
f13a ca 8f f0		        jp z, monitor_loop ; end of string; go back to the monitor 
f13d cd f9 f6		        call parsehex 
f140			        ; data value to write to now in DE 
f140			        ; confirm D byte is zero ie we're dealing with a single byte 
f140 7a			        ld a, d 
f141 fe 00		        cp 0 
f143 20 07		        jr nz, invalid 
f145			        ; do the write 
f145 dd 73 00		        ld (ix+0), e 
f148			        ; move to next memory address for the next byte 
f148 dd 23		        inc ix 
f14a 18 e8		        jr wm_nextbyte 
f14c			 
f14c			invalid: 
f14c 21 4e f8		        ld hl, invalid_msg 
f14f cd ff f5		        call outstring 
f152 c3 8f f0		        jp monitor_loop ; don't use ret 
f155			 
f155			; parse command line to display memory contents. call with (HL) pointing into input buffer after "dm " 
f155			do_dm: 
f155 cd e3 f6		        call skipspaces 
f158 cd f3 f6		        call parsehexorfail 
f15b d5			        push de ; start address 
f15c cd e3 f6		        call skipspaces 
f15f cd f9 f6		        call parsehex 
f162 7b			        ld a, e 
f163 b2			        or d 
f164 fe 00		        cp 0 
f166 20 02		        jr nz, dmgo 
f168			        ; ok DE=0, which is a problem. we'll dump 64K -- takes a while! 
f168 1e 01		        ld e, 1 ; force DE=0x0001 
f16a			dmgo: 
f16a e1			        pop  hl ; start address 
f16b cd 71 f1		        call dumpmem 
f16e c3 8f f0		        jp monitor_loop ; don't use ret, we get here by a jump and not a call. 
f171			 
f171			; display memory starting at (HL) length DE 
f171			dumpmem: 
f171			        ; start by writing the memory address 
f171 cd 21 f6		        call outhl 
f174 3e 3a		        ld a, 0x3a 
f176 cd 59 f6		        call outchar 
f179			 
f179			        ; now print the bytes from memory separated by spaces 
f179 3e 20		dumpnb: ld a, 0x20 
f17b cd 59 f6		        call outchar 
f17e 7e			        ld a, (hl) 
f17f cd 3c f6		        call outcharhex 
f182			 
f182			        ; next byte 
f182 23			        inc hl 
f183 1b			        dec de 
f184			 
f184			        ; got to the end? 
f184 7b			        ld a, e 
f185 b2			        or d 
f186 28 0c		        jr z, dumpdone 
f188			 
f188			        ; newline? 
f188 7d			        ld a, l 
f189 e6 0f		        and 0x0f 
f18b fe 00		        cp 0 
f18d 20 ea		        jr nz, dumpnb 
f18f			 
f18f cd 16 f6		dumpnl: call outnewline 
f192 18 dd		        jr dumpmem 
f194			 
f194			dumpdone: 
f194 cd 16 f6		        call outnewline 
f197 c9			        ret 
f198			 
f198			; jump to given address 
f198			do_run: 
f198 cd e3 f6		        call skipspaces 
f19b cd f3 f6		        call parsehexorfail 
f19e			        ; address to jump to is now in (DE) 
f19e eb			        ex de, hl ; put it in HL where we can use it 
f19f 01 6c f0		        ld bc, warmboot 
f1a2 c5			        push bc  ; push return address (monitor entry point) 
f1a3 e9			        jp (hl) 
f1a4			        ; we never get here. 
f1a4			 
f1a4			do_rboot: 
f1a4			        ; boot from RAM disk 
f1a4 cd e3 f6		        call skipspaces 
f1a7 cd f3 f6		        call parsehexorfail ; get physical page address in DE 
f1aa d5			        push de 
f1ab			        ; just for fun, let's use the 17th page! 
f1ab 3e ff		        ld a, 0xff 
f1ad d3 f8		        out (MMU_SELECT), a 
f1af			        ; load address: page address 1234 = physical address 01 23 40 00 
f1af 7a			        ld a, d 
f1b0 06 04		        ld b, 4 
f1b2 cb 3f		rb1a:   srl a 
f1b4 10 fc		        djnz rb1a ; repeat four times 
f1b6 d3 fc		        out (MMU_PTR_VAL0), a 
f1b8 06 04		        ld b, 4 
f1ba 7a			        ld a, d 
f1bb 4b			        ld c, e 
f1bc cb 21		rb1b:   sla c   ; shift B left one bit, top bit to carry, 0 to bottom bit 
f1be 17			        rla     ; shift A left one bit, copy carry to bit 0 
f1bf 10 fb		        djnz rb1b ; repeat four times 
f1c1 d3 fd		        out (MMU_PTR_VAL1), a 
f1c3			        ; we want to load from the specified address plus 0xFFC ... 0xFFF in order to get the 
f1c3			        ; 16-bit bootstrap magic number and 16-bit load/jump address into HL 
f1c3 79			        ld a, c 
f1c4 f6 0f		        or 0x0f 
f1c6 d3 fe		        out (MMU_PTR_VAL2), a 
f1c8 3e fc		        ld a, 0xfc 
f1ca d3 ff		        out (MMU_PTR_VAL3), a 
f1cc			        ; first read in the signature, should be be BA BE 
f1cc db fa		        in a, (MMU_PAGE17) 
f1ce fe ba		        cp 0xBA 
f1d0 20 31		        jr nz, rbfail 
f1d2 db fa		        in a, (MMU_PAGE17) 
f1d4 fe be		        cp 0xBE 
f1d6 20 2b		        jr nz, rbfail 
f1d8			        ; now read in that load address 
f1d8 db fa		        in a, (MMU_PAGE17) 
f1da 6f			        ld l, a 
f1db db fa		        in a, (MMU_PAGE17) 
f1dd 67			        ld h, a 
f1de			        ; set the pointer to the correct address 
f1de 79			        ld a, c 
f1df d3 fe		        out (MMU_PTR_VAL2), a 
f1e1 af			        xor a 
f1e2 d3 ff		        out (MMU_PTR_VAL3), a 
f1e4			        ; print out our intentions 
f1e4 e5			        push hl 
f1e5 21 ec f8		        ld hl, rboot_msg 
f1e8 cd ff f5		        call outstring 
f1eb e1			        pop hl 
f1ec e5			        push hl ; stash load/jump address 
f1ed cd 21 f6		        call outhl 
f1f0 cd 16 f6		        call outnewline 
f1f3			        ; now read the page of memory in 
f1f3 0e fa		        ld c, MMU_PAGE17 
f1f5 16 10		        ld d, 16 
f1f7 06 00		        ld b, 0 
f1f9 ed b2		rb1c:   inir ; read 256 bytes from port MMU_PAGE17 to (HL), incrementing HL as we go 
f1fb 15			        dec d 
f1fc 20 fb		        jr nz, rb1c ; repeat until 16*256=0x1000 bytes read 
f1fe dd e1		        pop ix ; load/boot vector 
f200 e1			        pop hl ; we enter the bootstrap with base page of RAM disk in HL 
f201 dd e9		        jp (ix) ; jump into bootstrap 
f203			        ; bootstrap can never return 
f203 21 18 f9		rbfail: ld hl, rboot_fail_msg 
f206 cd ff f5		        call outstring 
f209 c3 8f f0		        jp monitor_loop 
f20c			 
f20c			        ; before we had "the 17th page" we just mapped it in and copied: 
f20c			        ; in some ways this is much simpler!! but it doesn't help us when 
f20c			        ; we want to load somewhere other than 0x1000. 
f20c			        ; ; we're going to read this page in at 0x1000, so let's map it at 0x2000 
f20c			        ; ld a, 2 
f20c			        ; out (MMU_SELECT), a 
f20c			        ; ld a, d 
f20c			        ; out (MMU_FRAMEHI), a 
f20c			        ; ld a, e 
f20c			        ; out (MMU_FRAMELO), a 
f20c			        ; ld de, 0x1000 ; write to 0x1000 
f20c			        ; ld hl, 0x2000 ; read from mapped page at 0x2000 
f20c			        ; ld bc, 0x1000 ; 4KB 
f20c			        ; ldir ; copy copy copy 
f20c			        ; ; put RAM back 
f20c			        ; ld a, 2 
f20c			        ; out (MMU_FRAMELO), a 
f20c			        ; xor a 
f20c			        ; out (MMU_FRAMEHI), a 
f20c			        ; pop hl ; we enter the bootstrap with base page of RAM disk in HL 
f20c			        ; jp 0x1000 ; jump into bootstrap 
f20c			 
f20c			do_mmu: 
f20c			        ; show MMU state 
f20c 21 9a f8		        ld hl, mmu_header_msg 
f20f cd ff f5		        call outstring 
f212 db f8		        in a, (MMU_SELECT) 
f214 f5			        push af ; save current MMU_SELECT register value (ie, stop confusing Will) 
f215 1e 00		        ld e, 0 
f217			mmunextpage: 
f217 7b			        ld a, e 
f218 d3 f8		        out (MMU_SELECT), a 
f21a 07			        rlca 
f21b 07			        rlca 
f21c 07			        rlca 
f21d 07			        rlca 
f21e 57			        ld d, a 
f21f			        ; page start address 
f21f cd 3c f6		        call outcharhex 
f222 3e 00		        ld a, 0 
f224 cd 3c f6		        call outcharhex 
f227 3e 2d		        ld a, '-' 
f229 cd 59 f6		        call outchar 
f22c			        ; page end address 
f22c 7a			        ld a, d 
f22d f6 0f		        or 0x0f 
f22f cd 3c f6		        call outcharhex 
f232 3e ff		        ld a, 0xff 
f234 cd 3c f6		        call outcharhex 
f237 3e 09		        ld a, '\t' 
f239 cd 59 f6		        call outchar 
f23c			        ; physical address 
f23c db fc		        in a, (MMU_FRAMEHI) 
f23e cd 3c f6		        call outcharhex 
f241 db fd		        in a, (MMU_FRAMELO) 
f243 cd 3c f6		        call outcharhex 
f246 3e 00		        ld a, 0 
f248 cd 3c f6		        call outcharhex 
f24b 3e 30		        ld a, '0' 
f24d cd 59 f6		        call outchar 
f250 3e 2d		        ld a, '-' 
f252 cd 59 f6		        call outchar 
f255 db fc		        in a, (MMU_FRAMEHI) 
f257 cd 3c f6		        call outcharhex 
f25a db fd		        in a, (MMU_FRAMELO) 
f25c cd 3c f6		        call outcharhex 
f25f 3e ff		        ld a, 0xff 
f261 cd 3c f6		        call outcharhex 
f264 3e 46		        ld a, 'F' 
f266 cd 59 f6		        call outchar 
f269 3e 09		        ld a, '\t' 
f26b cd 59 f6		        call outchar 
f26e 3e 09		        ld a, '\t' 
f270 cd 59 f6		        call outchar 
f273			        ; permissions 
f273 db fb		        in a, (MMU_PERM) 
f275 57			        ld d, a 
f276 cd 3c f6		        call outcharhex 
f279 3e 20		        ld a, ' ' 
f27b cd 59 f6		        call outchar 
f27e 7a			        ld a, d 
f27f e6 02		        and 0x02 
f281 28 06		        jr z,testread 
f283 21 cb f8		        ld hl, mmu_write_msg 
f286 cd ff f5		        call outstring 
f289			testread: 
f289 7a			        ld a, d 
f28a e6 01		        and 0x01 
f28c 28 06		        jr z, mmudone 
f28e 21 c5 f8		        ld hl, mmu_read_msg 
f291 cd ff f5		        call outstring 
f294			mmudone: 
f294 cd 16 f6		        call outnewline 
f297 1c			        inc e 
f298 7b			        ld a, e 
f299 fe 10		        cp 0x10 
f29b c2 17 f2		        jp nz, mmunextpage 
f29e			        ; finally print the MMU pointer 
f29e 21 d2 f8		        ld hl, mmu_ptr_msg 
f2a1 cd ff f5		        call outstring 
f2a4 3e ff		        ld a, 0xFF 
f2a6 d3 f8		        out (MMU_SELECT), a 
f2a8 db fc		        in a, (MMU_PTR_VAL0) 
f2aa cd 3c f6		        call outcharhex 
f2ad db fd		        in a, (MMU_PTR_VAL1) 
f2af cd 3c f6		        call outcharhex 
f2b2 db fe		        in a, (MMU_PTR_VAL2) 
f2b4 cd 3c f6		        call outcharhex 
f2b7 db ff		        in a, (MMU_PTR_VAL3) 
f2b9 cd 3c f6		        call outcharhex 
f2bc cd 16 f6		        call outnewline 
f2bf			        ; tidy up 
f2bf f1			        pop af 
f2c0 d3 f8		        out (MMU_SELECT), a ; restore MMU select register 
f2c2 c3 8f f0		        jp monitor_loop 
f2c5			 
f2c5			do_cp: 
f2c5			        ; copy memory 
f2c5 cd e3 f6		        call skipspaces 
f2c8 cd f3 f6		        call parsehexorfail 
f2cb			        ; src is now in DE 
f2cb d5			        push de 
f2cc cd e3 f6		        call skipspaces 
f2cf cd f3 f6		        call parsehexorfail 
f2d2			        ; dst is now in DE 
f2d2 d5			        push de 
f2d3 cd e3 f6		        call skipspaces 
f2d6 cd f3 f6		        call parsehexorfail 
f2d9			        ; len is now in DE 
f2d9 d5			        push de 
f2da			        ; set up for LDIR: 
f2da			        ; DE dst 
f2da			        ; HL src 
f2da			        ; BC count 
f2da c1			        pop bc 
f2db d1			        pop de 
f2dc e1			        pop hl 
f2dd ed b0		        ldir ; copy copy copy! 
f2df c3 8f f0		        jp monitor_loop 
f2e2			 
f2e2			do_sp: 
f2e2 cd e3 f6		        call skipspaces 
f2e5 7e			        ld a, (hl) ; check if we're at the end of string? 
f2e6 fe 00		        cp 0 
f2e8 28 06		        jr z, showsp 
f2ea			        ; if not, load SP first 
f2ea cd f9 f6		        call parsehex 
f2ed			        ; new SP is now in DE 
f2ed d5			        push de 
f2ee e1			        pop hl 
f2ef f9			        ld sp, hl 
f2f0			showsp: 
f2f0			        ; you can't read SP directly but you can add it to HL (go figure) 
f2f0 21 54 f9		        ld hl, sp_msg 
f2f3 cd ff f5		        call outstring 
f2f6 21 00 00		        ld hl, 0 
f2f9 39			        add hl, sp 
f2fa cd 21 f6		        call outhl 
f2fd cd 16 f6		        call outnewline 
f300 c3 8f f0		        jp monitor_loop 
f303			 
f303			do_buf: 
f303 cd e3 f6		        call skipspaces 
f306 7e			        ld a, (hl) ; check if we're at the end of string? 
f307 fe 00		        cp 0 
f309 28 06		        jr z, showbuf 
f30b			        ; if not, load SP first 
f30b cd f9 f6		        call parsehex 
f30e			        ; new SP is now in DE 
f30e d5			        push de 
f30f fd e1		        pop iy 
f311			showbuf: 
f311 21 58 f9		        ld hl, buf_msg 
f314 cd ff f5		        call outstring 
f317 fd e5		        push iy 
f319 e1			        pop hl 
f31a cd 21 f6		        call outhl 
f31d cd 16 f6		        call outnewline 
f320 c3 8f f0		        jp monitor_loop 
f323			 
f323			do_rerase: 
f323 cd e3 f6		        call skipspaces 
f326 11 00 02		        ld de, 0x200 ; default disk base 
f329 7e			        ld a, (hl)   ; end of string? 
f32a fe 00		        cp 0 
f32c 28 03		        jr z, erasewarn 
f32e cd f9 f6		        call parsehex 
f331			erasewarn: 
f331			        ; target page in DE 
f331 21 8b f9		        ld hl, erasewarn_msg 
f334 cd ff f5		        call outstring 
f337 cd 33 f6		        call outde 
f33a cd 90 f3		        call plzconfirm 
f33d			        ; if plzconfirm returns, we're good to go. 
f33d			        ; start address remains in DE 
f33d			        ; store MMU state 
f33d 3e 0d		        ld a, 0x0d 
f33f d3 f8		        out (MMU_SELECT), a ; select Dxxx frame 
f341 db fc		        in a, (MMU_FRAMEHI) 
f343 47			        ld b, a 
f344 db fd		        in a, (MMU_FRAMELO) 
f346 4f			        ld c, a 
f347 c5			        push bc ; store MMU state on the stack 
f348 cd 16 f6		        call outnewline 
f34b 01 00 02		        ld bc, 0x200 ; put length in bc 
f34e eb			        ex de, hl ; put first page in hl 
f34f			ernextpage: 
f34f			        ; print page number 
f34f cd 21 f6		        call outhl 
f352 7d			        ld a, l 
f353 e6 0f		        and 0x0f 
f355 fe 0f		        cp 0x0f 
f357 20 05		        jr nz, erspace 
f359			        ; print CR LF 
f359 cd 16 f6		        call outnewline 
f35c 18 05		        jr erwritepage ; skip space 
f35e			erspace:    ; print a space 
f35e 3e 20		        ld a, 0x20 
f360 cd 59 f6		        call outchar 
f363			erwritepage:; map and write ("erase") page 
f363			        ; map page 
f363 7c			        ld a, h 
f364 d3 fc		        out (MMU_FRAMEHI), a 
f366 7d			        ld a, l 
f367 d3 fd		        out (MMU_FRAMELO), a 
f369 e5			        push hl ; stash page number 
f36a c5			        push bc ; stash counter 
f36b			        ; write page 
f36b 21 00 d0		        ld hl, 0xd000  ; first byte (source address) 
f36e 11 01 d0		        ld de, 0xd001  ; second byte (target address) 
f371 01 ff 0f		        ld bc, 0x0fff  ; block size - 1 
f374 3e e5		        ld a, 0xe5 
f376 77			        ld (hl), a     ; write first byte 
f377 ed b0		        ldir           ; copy copy copy! 
f379 c1			        pop bc ; recover counter 
f37a e1			        pop hl ; recover page number 
f37b 23			        inc hl ; next page 
f37c 0b			        dec bc ; one less to go 
f37d			        ; test for last page 
f37d 78			        ld a, b 
f37e b1			        or c 
f37f fe 00		        cp 0 
f381 20 cc		        jr nz, ernextpage 
f383			        ; done! 
f383 cd 16 f6		        call outnewline 
f386			fixmmu: 
f386			        ; restore MMU to default state 
f386 c1			        pop bc 
f387 78			        ld a, b 
f388 d3 fc		        out (MMU_FRAMEHI), a 
f38a 79			        ld a, c 
f38b d3 fd		        out (MMU_FRAMELO), a 
f38d c3 8f f0		        jp monitor_loop 
f390			 
f390			plzconfirm: 
f390 21 0f fa		        ld hl, genwarn_msg 
f393 cd ff f5		        call outstring 
f396			erasewaitkey: 
f396 cd da f6		        call incharwait 
f399 e6 df		        and 0xdf ; convert to upper case 
f39b fe 59		        cp 'Y' 
f39d c8			        ret z 
f39e fe 4e		        cp 'N' 
f3a0 20 f4		        jr nz, erasewaitkey 
f3a2 cd 16 f6		        call outnewline 
f3a5 e1			        pop hl ; remove return address from stack (we were call'ed but won't ret) 
f3a6 c3 8f f0		        jp monitor_loop 
f3a9			 
f3a9			do_rread: 
f3a9 e5			        push hl 
f3aa cd 68 f5		        call flash_initialise ; check flash is present and matches our expectations 
f3ad e1			        pop hl 
f3ae cd e3 f6		        call skipspaces 
f3b1 01 00 02		        ld bc, 0x200 ; default flash base 
f3b4 11 00 02		        ld de, 0x200 ; default ramdisk base 
f3b7 7e			        ld a, (hl) ; end of string? 
f3b8 fe 00		        cp 0 
f3ba 28 1a		        jr z, readwarn 
f3bc cd f9 f6		        call parsehex 
f3bf			        ; ramdisk base now in DE 
f3bf cd e3 f6		        call skipspaces 
f3c2 7e			        ld a, (hl) ; end of string? 
f3c3 fe 00		        cp 0 
f3c5 28 0f		        jr z, readwarn 
f3c7 d5			        push de ; push disk base 
f3c8 cd f9 f6		        call parsehex 
f3cb			        ; flash base now in DE 
f3cb			        ; quick sanity check 
f3cb 7a			        ld a, d 
f3cc e6 f0		        and 0xf0 
f3ce fe 00		        cp 0 
f3d0 c2 4c f1		        jp nz, invalid 
f3d3 d5			        push de 
f3d4 c1			        pop bc ; put flash base in BC 
f3d5 d1			        pop de ; recover ramdisk base in DE 
f3d6			readwarn: 
f3d6			        ; target memory page in de 
f3d6			        ; target flash address in bc ... *but* still needs shifting left four bits. 
f3d6 21 ac f9		        ld hl, readwarn1_msg 
f3d9 cd ff f5		        call outstring 
f3dc cd 33 f6		        call outde 
f3df 21 cc f9		        ld hl, readwarn2_msg 
f3e2 cd ff f5		        call outstring 
f3e5 cd 2a f6		        call outbc 
f3e8 cd 90 f3		        call plzconfirm 
f3eb			        ; now we can do the read 
f3eb cd 16 f6		        call outnewline 
f3ee			        ; shift BC four bits left 
f3ee 3e 04		        ld a, 4 
f3f0 a7			readsh: and a ; clear carry flag 
f3f1 cb 11		        rl c  ; shift C left one bit, top bit to carry 
f3f3 cb 10		        rl b  ; shift B left one bit, shift in carry bit 
f3f5 3d			        dec a 
f3f6 fe 00		        cp 0 
f3f8 20 f6		        jr nz, readsh 
f3fa			        ; BC contains correct flash address now 
f3fa 3e 0d		        ld a, 0x0d 
f3fc d3 f8		        out (MMU_SELECT), a ; select Dxxx frame 
f3fe db fc		        in a, (MMU_FRAMEHI) 
f400 67			        ld h, a 
f401 db fd		        in a, (MMU_FRAMELO) 
f403 6f			        ld l, a 
f404 e5			        push hl ; store MMU state on the stack 
f405 c5			        push bc ; move flash address into HL 
f406 e1			        pop hl 
f407 01 00 02		        ld bc, 0x200 ; put disk length (4K pages) in BC 
f40a			        ; now: 
f40a			        ;  BC -- number of pages remaining to copy 
f40a			        ;  DE -- ram page number 
f40a			        ;  HL -- flash page number 
f40a			readnextpage: 
f40a			        ; tell them what page we're on 
f40a cd 33 f6		        call outde 
f40d 7b			        ld a, e 
f40e e6 0f		        and 0x0f 
f410 fe 0f		        cp 0x0f 
f412 20 05		        jr nz, rnpspace 
f414 cd 16 f6		        call outnewline 
f417 18 05		        jr readcopypage 
f419			rnpspace: 
f419 3e 20		        ld a, ' ' 
f41b cd 59 f6		        call outchar 
f41e			readcopypage: 
f41e			        ; now do the actual copying 
f41e			        ; map the page in 
f41e 7a			        ld a, d 
f41f d3 fc		        out (MMU_FRAMEHI), a 
f421 7b			        ld a, e 
f422 d3 fd		        out (MMU_FRAMELO), a 
f424 d5			        push de ; save ram page number 
f425 e5			        push hl ; save flash page number 
f426 cd c0 f5		        call spi_start 
f429 3e 0b		        ld a, 0x0b ; fast read command 
f42b d3 1a		        out (SPI_TX), a 
f42d			        ; now we send the memory address 
f42d cd 55 f4		        call flash_sendaddress 
f430 d3 1a		        out (SPI_TX), a ; dummy byte while fast read fills pipeline or whatever 
f432 21 00 d0		        ld hl, 0xd000 ; target address 
f435			readnextbyte: 
f435 d3 1a		        out (SPI_TX), a ; send dummy byte 
f437 db 1b		        in a, (SPI_RX) 
f439 77			        ld (hl), a 
f43a 23			        inc hl 
f43b 7c			        ld a, h 
f43c fe e0		        cp 0xe0 ; when we get to 0xe000 we're done 
f43e 20 f5		        jr nz, readnextbyte 
f440 cd bb f5		        call spi_end 
f443			        ; move flash address forward 16x256 bytes ie 4KB 
f443 e1			        pop hl 
f444 11 10 00		        ld de, 16 
f447 19			        add hl, de 
f448 d1			        pop de ; recover ram page number 
f449 13			        inc de ; next page 
f44a 0b			        dec bc ; one down 
f44b 78			        ld a, b 
f44c b1			        or c 
f44d 20 bb		        jr nz, readnextpage 
f44f			        ; ok we're done 
f44f cd 16 f6		        call outnewline 
f452 c3 86 f3		        jp fixmmu 
f455			 
f455			flash_sendaddress: 
f455 7c			        ld a, h 
f456 d3 1a		        out (SPI_TX), a ; address byte 0 
f458 7d			        ld a, l 
f459 d3 1a		        out (SPI_TX), a ; address byte 1 
f45b af			        xor a 
f45c d3 1a		        out (SPI_TX), a ; address byte 2 (always 0 for our code) 
f45e c9			        ret 
f45f			 
f45f			do_rwrite: 
f45f e5			        push hl 
f460 cd 68 f5		        call flash_initialise ; check flash is present and matches our expectations 
f463 e1			        pop hl 
f464 cd e3 f6		        call skipspaces 
f467 01 00 02		        ld bc, 0x200 ; default flash base 
f46a 11 00 02		        ld de, 0x200 ; default ramdisk base 
f46d 7e			        ld a, (hl) ; end of string? 
f46e fe 00		        cp 0 
f470 28 1a		        jr z, writewarn 
f472 cd f9 f6		        call parsehex 
f475			        ; ramdisk base now in DE 
f475 cd e3 f6		        call skipspaces 
f478 7e			        ld a, (hl) ; end of string? 
f479 fe 00		        cp 0 
f47b 28 0f		        jr z, writewarn 
f47d d5			        push de ; push disk base 
f47e cd f9 f6		        call parsehex 
f481			        ; flash base now in DE 
f481			        ; quick sanity check 
f481 7a			        ld a, d 
f482 e6 f0		        and 0xf0 
f484 fe 00		        cp 0 
f486 c2 4c f1		        jp nz, invalid 
f489 d5			        push de 
f48a c1			        pop bc ; put flash base in BC 
f48b d1			        pop de ; recover ramdisk base in DE 
f48c			writewarn: 
f48c			        ; target memory page in de 
f48c			        ; target flash address in bc ... *but* still needs shifting left four bits. 
f48c 21 de f9		        ld hl, writewarn1_msg 
f48f cd ff f5		        call outstring 
f492 cd 33 f6		        call outde 
f495 21 ff f9		        ld hl, writewarn2_msg 
f498 cd ff f5		        call outstring 
f49b cd 2a f6		        call outbc 
f49e cd 90 f3		        call plzconfirm 
f4a1			        ; now we can do the read 
f4a1 cd 16 f6		        call outnewline 
f4a4			        ; shift BC four bits left 
f4a4 3e 04		        ld a, 4 
f4a6 a7			writesh: and a ; clear carry flag 
f4a7 cb 11		        rl c  ; shift C left one bit, top bit to carry 
f4a9 cb 10		        rl b  ; shift B left one bit, shift in carry bit 
f4ab 3d			        dec a 
f4ac fe 00		        cp 0 
f4ae 20 f6		        jr nz, writesh 
f4b0			        ; BC contains correct flash address now 
f4b0 3e 0d		        ld a, 0x0d 
f4b2 d3 f8		        out (MMU_SELECT), a ; select Dxxx frame 
f4b4 db fc		        in a, (MMU_FRAMEHI) 
f4b6 67			        ld h, a 
f4b7 db fd		        in a, (MMU_FRAMELO) 
f4b9 6f			        ld l, a 
f4ba e5			        push hl ; store MMU state on the stack 
f4bb c5			        push bc ; move flash address into HL 
f4bc e1			        pop hl 
f4bd 01 00 02		        ld bc, 0x200 ; put disk length (4K pages) in BC -- should be 0x200 
f4c0			        ; now: 
f4c0			        ;   BC -- number of pages remaining to copy 
f4c0			        ;   DE -- ram page number 
f4c0			        ;   HL -- flash page number 
f4c0			writenextpage: 
f4c0			        ; tell them what page we're on 
f4c0 cd 33 f6		        call outde 
f4c3 7b			        ld a, e 
f4c4 e6 0f		        and 0x0f 
f4c6 fe 0f		        cp 0x0f 
f4c8 20 05		        jr nz, wnpspace 
f4ca cd 16 f6		        call outnewline 
f4cd 18 05		        jr writecopypage 
f4cf			wnpspace: 
f4cf 3e 20		        ld a, ' ' 
f4d1 cd 59 f6		        call outchar 
f4d4			writecopypage: 
f4d4			        ; first we verify the content of the flash to see if it matches what we have 
f4d4 d5			        push de ; store RAM page number 
f4d5 7a			        ld a, d 
f4d6 d3 fc		        out (MMU_FRAMEHI), a 
f4d8 7b			        ld a, e 
f4d9 d3 fd		        out (MMU_FRAMELO), a 
f4db cd 3d f5		        call flash_verify_4k 
f4de fe 00		        cp 0x00 ; identical? 
f4e0 28 4a		        jr z, writepagedone ; skip write (yay) 
f4e2			        ; ok, now do the write 
f4e2 e5			        push hl ; store flash page number 
f4e3 cd e6 f5		        call flash_prepare_write 
f4e6 cd c0 f5		        call spi_start 
f4e9 3e 20		        ld a, 0x20 ; sector (4K) erase command 
f4eb d3 1a		        out (SPI_TX), a 
f4ed cd 55 f4		        call flash_sendaddress 
f4f0 cd bb f5		        call spi_end 
f4f3			        ; we program the sector in 16 sets of 256 bytes, 16*256=4096. 
f4f3 11 00 d0		        ld de, 0xd000 ; start address in mapped RAM 
f4f6			ppnext256: 
f4f6 cd e6 f5		        call flash_prepare_write 
f4f9 cd c0 f5		        call spi_start 
f4fc 3e 02		        ld a, 0x02 ; page program command 
f4fe d3 1a		        out (SPI_TX), a 
f500 cd 55 f4		        call flash_sendaddress 
f503			        ; now send 256 bytes of data 
f503			ppnextbyte: 
f503 1a			        ld a, (de) 
f504 d3 1a		        out (SPI_TX), a 
f506 13			        inc de 
f507 7b			        ld a, e 
f508 fe 00		        cp 0 
f50a 20 f7		        jr nz, ppnextbyte 
f50c cd bb f5		        call spi_end 
f50f 23			        inc hl ; advance flash address by 256 bytes 
f510 7a			        ld a, d 
f511 fe e0		        cp 0xe0 ; made it to the end of mapped pages yet? 
f513 20 e1		        jr nz, ppnext256 
f515			        ; now we verify the 4K that we just wrote 
f515 e1			        pop hl ; recover original flash page number 
f516 cd de f5		        call flash_finish_write 
f519 cd 3d f5		        call flash_verify_4k 
f51c fe 00		        cp 0x00 ; identical? 
f51e 28 0c		        jr z, writepagedone 
f520			        ; they differ :( 
f520 cd 16 f6		        call outnewline 
f523 21 17 fa		        ld hl, verifybad_msg 
f526 cd ff f5		        call outstring 
f529 cd 4c f1		        call invalid ; sorry, you lose. 
f52c			writepagedone: 
f52c			        ; advance flash address by 4KB 
f52c 11 10 00		        ld de, 16 
f52f 19			        add hl, de 
f530 d1			        pop de ; recover RAM page number 
f531 13			        inc de ; next page 
f532 0b			        dec bc ; one down 
f533 78			        ld a, b 
f534 b1			        or c 
f535 20 89		        jr nz, writenextpage 
f537			        ; ok we're done 
f537 cd 16 f6		        call outnewline 
f53a c3 86 f3		        jp fixmmu 
f53d			 
f53d			flash_verify_4k: 
f53d			        ; compare flash at page HL against RAM at 0xd000 for 4K bytes 
f53d e5			        push hl 
f53e cd c0 f5		        call spi_start 
f541 3e 0b		        ld a, 0x0b ; fast read command 
f543 d3 1a		        out (SPI_TX), a 
f545 cd 55 f4		        call flash_sendaddress 
f548 d3 1a		        out (SPI_TX), a ; dummy byte for fast read cmd pipeline 
f54a 21 00 d0		        ld hl, 0xd000 
f54d d3 1a		vrnext: out (SPI_TX), a ; dummy write 
f54f db 1b		        in a, (SPI_RX) 
f551 be			        cp (hl) 
f552 20 0d		        jr nz, verifyfail 
f554 23			        inc hl 
f555 7c			        ld a, h 
f556 fe e0		        cp 0xe0 
f558 20 f3		        jr nz, vrnext 
f55a			verifypass: 
f55a cd bb f5		        call spi_end 
f55d e1			        pop hl 
f55e 3e 00		        ld a, 0x00 ; A=0 -> identical 
f560 c9			        ret 
f561			verifyfail: 
f561 cd bb f5		        call spi_end 
f564 e1			        pop hl 
f565 3e ff		        ld a, 0xff ; A=FF -> non-identical 
f567 c9			        ret 
f568			 
f568			flash_initialise: 
f568 cd b7 f5		        call spi_init 
f56b 21 5d f9		        ld hl, type_check_msg 
f56e cd ff f5		        call outstring 
f571 cd c0 f5		        call spi_start 
f574 3e 9f		        ld a, 0x9f ; identify/RDID command 
f576 d3 1a		        out (SPI_TX), a ; send command 
f578 af			        xor a 
f579 d3 1a		        out (SPI_TX), a ; send three address bytes 
f57b d3 1a		        out (SPI_TX), a 
f57d d3 1a		        out (SPI_TX), a 
f57f			        ; read out ID value (3 bytes) 
f57f d3 1a		        out (SPI_TX), a 
f581 db 1b		        in a, (SPI_RX) 
f583 67			        ld h, a 
f584 d3 1a		        out (SPI_TX), a 
f586 db 1b		        in a, (SPI_RX) 
f588 6f			        ld l, a 
f589 d3 1a		        out (SPI_TX), a 
f58b db 1b		        in a, (SPI_RX) 
f58d 5f			        ld e, a 
f58e cd bb f5		        call spi_end 
f591			 
f591			        ; print type 
f591 cd 21 f6		        call outhl 
f594 7b			        ld a, e 
f595 cd 3c f6		        call outcharhex 
f598			 
f598			        ; check value received 
f598 7c			        ld a, h 
f599 fe c2		        cp FLASH_MAN 
f59b 20 11		        jr nz, type_check_fail 
f59d 7d			        ld a, l 
f59e fe 20		        cp FLASH_DEV1 
f5a0 20 0c		        jr nz, type_check_fail 
f5a2 7b			        ld a, e 
f5a3 fe 17		        cp FLASH_DEV2 
f5a5 20 07		        jr nz, type_check_fail 
f5a7			 
f5a7			        ; type is OK! 
f5a7 21 77 f9		        ld hl, type_check_ok_msg 
f5aa cd ff f5		        call outstring 
f5ad c9			        ret 
f5ae			type_check_fail: 
f5ae 21 7f f9		        ld hl, type_check_fail_msg 
f5b1 cd ff f5		        call outstring 
f5b4 c3 8f f0		        jp monitor_loop ; give up 
f5b7			 
f5b7			spi_init: 
f5b7 3e 01		        ld a, 1 ; SPI CLK is sysclk/2*(1+n) ie for 128MHz clock, divisor 0 is 64MHz, 1 is 32MHz, 3 is 16MHz etc 
f5b9 d3 1c		        out (SPI_DIVISOR), a 
f5bb			        ; fall through to spi_end 
f5bb			spi_end: 
f5bb 3e ff		        ld a, 0xff 
f5bd d3 18		        out (SPI_CHIPSELECT), a 
f5bf c9			        ret 
f5c0			 
f5c0			spi_start: 
f5c0 3e fe		        ld a, 0xfe ; flash is on CS0. 
f5c2 d3 18		        out (SPI_CHIPSELECT), a 
f5c4 c9			        ret 
f5c5			 
f5c5			flash_write_enable: 
f5c5 cd c0 f5		        call spi_start 
f5c8 3e 06		        ld a, 0x06 
f5ca d3 1a		        out (SPI_TX), a 
f5cc cd bb f5		        call spi_end 
f5cf			 
f5cf			flash_read_status_register: 
f5cf cd c0 f5		        call spi_start 
f5d2 3e 05		        ld a, 0x05 
f5d4 d3 1a		        out (SPI_TX), a 
f5d6 d3 1a		        out (SPI_TX), a 
f5d8 cd bb f5		        call spi_end 
f5db db 1b		        IN a, (SPI_RX) 
f5dd c9			        ret ; status in A 
f5de			 
f5de			flash_finish_write: 
f5de cd cf f5		        call flash_read_status_register 
f5e1 cb 47		        bit 0, a ; check WIP (write in progress) 
f5e3 c8			        ret z    ; return if write done 
f5e4 18 f8		        jr flash_finish_write ; check again 
f5e6			 
f5e6			flash_prepare_write: 
f5e6 cd cf f5		        call flash_read_status_register 
f5e9 cb 47		        bit 0, a ; check WIP (write in progress) 
f5eb 20 f9		        jr nz, flash_prepare_write ; wait until no longer writing 
f5ed cb 4f		        bit 1, a ; check WEL (write enable latch) 
f5ef c0			        ret nz   ; return if set 
f5f0 cd c5 f5		        call flash_write_enable ; enable writes 
f5f3 18 f1		        jr flash_prepare_write  ; check again 
f5f5			 
f5f5			 
f5f5			; compare strings at (HL) and (DE), input buffer in (HL) and command in (DE). 
f5f5			; return with flags NZ -> inequality 
f5f5			; return with flags  Z -> equal ie string at (DE) is a prefix of (HL) 
f5f5			cmdcompare: 
f5f5 1a			        ld a, (de) 
f5f6 fe 00		        cp 0 
f5f8 c8			        ret z    ; end of string at (DE) -> return zero flag 
f5f9 be			        cp (hl) 
f5fa c0			        ret nz   ; non-matching -> return nonzero flag 
f5fb 13			        inc de 
f5fc 23			        inc hl 
f5fd 18 f6		        jr cmdcompare 
f5ff			 
f5ff			; outstring: Print the string at (HL) until 0 byte is found 
f5ff			; destroys: AF HL 
f5ff			outstring: 
f5ff 7e			        ld a, (hl)     ; load next character 
f600 a7			        and a          ; test if zero 
f601 c8			        ret z          ; return when we find a 0 byte 
f602 cd 59 f6		        call outchar 
f605 23			        inc hl         ; next char please 
f606 18 f7		        jr outstring 
f608			 
f608			; print the string at (HL) in hex (continues until 0 byte seen) 
f608			outstringhex: 
f608 7e			        ld a, (hl)     ; load next character 
f609 a7			        and a          ; test if zero 
f60a c8			        ret z          ; return when we find a 0 byte 
f60b cd 3c f6		        call outcharhex 
f60e 3e 20		        ld a, 0x20 ; space 
f610 cd 59 f6		        call outchar 
f613 23			        inc hl         ; next char please 
f614 18 f2		        jr outstringhex 
f616			 
f616			; output a newline 
f616			outnewline: 
f616 3e 0d		        ld a, 0x0d   ; output newline 
f618 cd 59 f6		        call outchar 
f61b 3e 0a		        ld a, 0x0a 
f61d cd 59 f6		        call outchar 
f620 c9			        ret 
f621			 
f621			outhl:  ; prints HL in hex. Destroys AF. 
f621 7c			        ld a, h 
f622 cd 3c f6		        call outcharhex 
f625 7d			        ld a, l 
f626 cd 3c f6		        call outcharhex 
f629 c9			        ret 
f62a			 
f62a			outbc:  ; prints BC in hex. Destroys AF. 
f62a 78			        ld a, b 
f62b cd 3c f6		        call outcharhex 
f62e 79			        ld a, c 
f62f cd 3c f6		        call outcharhex 
f632 c9			        ret 
f633			 
f633			outde:  ; prints DE in hex. Destroys AF. 
f633 7a			        ld a, d 
f634 cd 3c f6		        call outcharhex 
f637 7b			        ld a, e 
f638 cd 3c f6		        call outcharhex 
f63b c9			        ret 
f63c			 
f63c			; print the byte in A as a two-character hex value 
f63c			outcharhex: 
f63c c5			        push bc 
f63d 4f			        ld c, a  ; copy value 
f63e			        ; print the top nibble 
f63e 1f			        rra 
f63f 1f			        rra 
f640 1f			        rra 
f641 1f			        rra 
f642 cd 4b f6		        call outnibble 
f645			        ; print the bottom nibble 
f645 79			        ld a, c 
f646 cd 4b f6		        call outnibble 
f649 c1			        pop bc 
f64a c9			        ret 
f64b			 
f64b			; print the nibble in the low four bits of A 
f64b			outnibble: 
f64b e6 0f		        and 0x0f ; mask off low four bits 
f64d fe 0a		        cp 10 
f64f 38 02		        jr c, numeral ; less than 10? 
f651 c6 07		        add 0x07 ; start at 'A' (10+7+0x30=0x41='A') 
f653 c6 30		numeral:add 0x30 ; start at '0' (0x30='0') 
f655 cd 59 f6		        call outchar 
f658 c9			        ret 
f659			 
f659			; outchar: Wait for UART TX idle, then print the char in A 
f659			; destroys: AF 
f659			outchar: 
f659 c5			        push bc 
f65a 47			        ld b, a 
f65b			        ; wait for transmitter to be idle 
f65b db 00		ocloop: in a, (UART0_STATUS) 
f65d cb 77		        bit 6, a 
f65f 20 fa		        jr nz, ocloop   ; loop while busy 
f661			 
f661			        ; now output the char to serial port 
f661 78			        ld a, b 
f662 d3 01		        out (UART0_DATA), a 
f664 c1			        pop bc 
f665 c9			        ret 
f666			 
f666			; instring: Read a typed string into (HL) terminate with 0 byte when CR seen (leaves (HL) pointing at the 0 byte) 
f666			;           Returns length of string (excluding 0 terminator) in C 
f666			;           Special handling for newline, backspace and non-printing characters. 
f666			;           If first character received is '@' it is not inserted into the buffer and the buffer is not echoed back (for bulk data load etc) 
f666			; DOES NOT PERFORM BUFFER LENGTH CHECKING! 
f666			instring: 
f666 0e 00		        ld c, 0        ; we use c to remember our string length 
f668 cd da f6		        call incharwait 
f66b fe 40		        cp '@' 
f66d 20 08		        jr nz, gotchar 
f66f			        ; we've got an @ so we should do a bulk load 
f66f cd 59 f6		        call outchar 
f672 18 41		        jr instringbulk 
f674			instringloop: 
f674 cd da f6		        call incharwait ; reads single byte into A 
f677			gotchar:; test for cr/lf 
f677 fe 0d		        cp 0x0d 
f679 28 36		        jr z, cr 
f67b fe 0a		        cp 0x0a 
f67d 28 32		        jr z, cr 
f67f			        ; test for backspace 
f67f fe 08		        cp 0x08 
f681 28 16		        jr z, backspace 
f683 fe 7f		        cp 0x7f 
f685 28 12		        jr z, backspace 
f687			        ; test for non-printing characters 
f687 fe 20		        cp 0x20 ; < 0x20? 
f689 da 74 f6		        jp c, instringloop  
f68c fe 7f		        cp 0x7f ; > 0x7f? 
f68e d2 74 f6		        jp nc, instringloop 
f691			        ; store the character in the buffer 
f691 77			        ld (hl), a 
f692 23			        inc hl 
f693 0c			        inc c 
f694 cd 59 f6		        call outchar ; echo back the character typed 
f697 18 db		        jr instringloop 
f699			backspace: 
f699 79			        ld a, c 
f69a fe 00		        cp 0 
f69c 28 d6		        jr z, instringloop ; cannot backspace past the start 
f69e 2b			        dec hl 
f69f 0d			        dec c 
f6a0 3e 08		        ld a, 0x08 ; move back 
f6a2 cd 59 f6		        call outchar 
f6a5 3e 20		        ld a, 0x20 ; print space 
f6a7 cd 59 f6		        call outchar 
f6aa 3e 08		        ld a, 0x08 ; move back again 
f6ac cd 59 f6		        call outchar 
f6af 18 c3		        jr instringloop 
f6b1			cr:      
f6b1 3e 00		        ld a, 0 
f6b3 77			        ld (hl), a 
f6b4 c9			        ret 
f6b5			 
f6b5			; a fast bulk version of instring 
f6b5			; does not echo back characters received after the first space, in order to avoid overflowing the rx fifo 
f6b5			; does not perform full terminal handling 
f6b5			instringbulk: 
f6b5 cd da f6		        call incharwait 
f6b8 fe 0d		        cp 0x0d 
f6ba 28 f5		        jr z, cr 
f6bc fe 0a		        cp 0x0a 
f6be 28 f1		        jr z, cr 
f6c0 77			        ld (hl), a 
f6c1 23			        inc hl 
f6c2 fe 20		        cp 0x20 
f6c4 28 05		        jr z, isbspace 
f6c6 cd 59 f6		        call outchar 
f6c9 18 ea		        jr instringbulk 
f6cb			isbspace: 
f6cb cd da f6		        call incharwait 
f6ce fe 0d		        cp 0x0d 
f6d0 28 df		        jr z, cr 
f6d2 fe 0a		        cp 0x0a 
f6d4 28 db		        jr z, cr 
f6d6 77			        ld (hl), a 
f6d7 23			        inc hl 
f6d8 18 f1		        jr isbspace 
f6da			 
f6da			 
f6da			 
f6da			; incharwait: Wait for UART RX, return character read in A 
f6da			; destroys: A 
f6da			incharwait: 
f6da db 00		        in a, (UART0_STATUS) 
f6dc cb 7f		        bit 7, a 
f6de 28 fa		        jr z, incharwait   ; loop while no character received 
f6e0 db 01		        in a, (UART0_DATA) 
f6e2 c9			        ret 
f6e3			 
f6e3			; advance HL until it no longer points at a space 
f6e3			skipspaces: 
f6e3 7e			        ld a, (hl) 
f6e4 fe 20		        cp 0x20 
f6e6 c0			        ret nz 
f6e7 23			        inc hl 
f6e8 18 f9		        jr skipspaces 
f6ea			 
f6ea			; convert character in A to upper case 
f6ea			toupper: 
f6ea fe 61		        cp 0x61    ; < "a" ? 
f6ec d8			        ret c 
f6ed fe 7b		        cp 0x7b 
f6ef d0			        ret nc 
f6f0 e6 5f		        and 0x5f 
f6f2 c9			        ret 
f6f3			 
f6f3			; if at end of string, jump to invalid, else continue 
f6f3			; and run parsehex 
f6f3			parsehexorfail: 
f6f3 7e			        ld a, (hl) 
f6f4 fe 00		        cp 0 
f6f6 ca 4c f1		        jp z, invalid 
f6f9			        ; fall through to parsehex 
f6f9			; read hex digits pointed to by hl, load into DE 
f6f9			; does not work when fed with non-hex digits!! 
f6f9			parsehex: 
f6f9 16 00		        ld d, 0 
f6fb 1e 00		        ld e, 0 
f6fd			parsemorehex: 
f6fd 7e			        ld a, (hl) 
f6fe fe 30		        cp 0x30 ; not a hex character? 
f700 d8			        ret c 
f701			        ; convert to nibble 
f701 fe 40		        cp 0x40 ; <= '9'? 
f703 38 02		        jr c, phnumeral 
f705 d6 07		        sub 7 
f707 d6 30		phnumeral: sub 0x30 
f709 e6 0f		        and 0xf 
f70b			        ; A now contains the nibble at (hl) ie bits are 0000nnnn 
f70b			        ; now we do: 
f70b			        ; D = D << 4 | E << 4 
f70b			        ; E = E << 4 | A 
f70b			        ; remember rl shifts 9 bits total; 8 bits in the register plus the carry bit from flags register 
f70b c5			        push bc ; don't clobber B 
f70c 06 04		        ld b, 4 ; prepare to do this four times 
f70e			phshift: 
f70e a7			        and a   ; clear carry flag (so we shift zeros into the low four bits of E) 
f70f cb 13		        rl e    ; rotate C register left one bit, top bit moves into carry flag 
f711 cb 12		        rl d    ; rotate B register left one bit, carry flag moves into lower bit 
f713 10 f9		        djnz phshift ; repeat four times please 
f715 c1			        pop bc 
f716 b3			        or e    ; combine C and A 
f717 5f			        ld e, a ; move A into C 
f718 23			        inc hl 
f719 18 e2		        jr parsemorehex 
f71b			 
f71b .. 00		coldbootmsg:        db "\r\nCold boot: zeroing RAM ", 0 
f735 ..			greeting:           db "\r" 
f736 ..			                    db "                    ___   ___  \r\n" 
f757 ..			                    db " ___  ___   ___ ___( _ ) / _ \\ \r\n" 
f778 ..			                    db "/ __|/ _ \\ / __|_  / _ \\| | | |\r\n" 
f799 ..			                    db "\\__ \\ (_) | (__ / / (_) | |_| |\r\n" 
f7ba ..			                    db "|___/\\___/ \\___/___\\___/ \\___/ \r\n" 
f7db .. 00		                    db "Z80 ROM Monitor (Will Sowerbutts, 2013-12-12)\r\n", 0 
f80b .. 00		monitor_prompt:     db "Z80> ", 0 
f811 .. 00		what_msg:           db "Error reduces\r\nYour expensive computer\r\nTo a simple stone.\r\n", 0 
f84e .. 00		invalid_msg:        db "Errors have occurred.\r\nWe won't tell you where or why.\r\nLazy programmers.\r\n", 0  
f89a .. 00		mmu_header_msg:     db "Virtual (F8)\tPhysical (FC FD)\tFlags (FB)\r\n", 0 
f8c5 .. 00		mmu_read_msg:       db "READ ", 0 
f8cb .. 00		mmu_write_msg:      db "WRITE ", 0 
f8d2 .. 00		mmu_ptr_msg:        db "17th Page Pointer (FA) = ",0 
f8ec .. 00		rboot_msg:          db "Loading stage 2 bootstrap from RAM disk to ", 0 
f918 .. 00		rboot_fail_msg:     db "Bad magic number. Gentlemen, please check your RAM disks.\r\n", 0 
f954 .. 00		sp_msg:             db "SP=", 0 
f958 .. 00		buf_msg:            db "BUF=", 0 
f95d .. 00		type_check_msg:     db "Checking SPI flash type: ", 0 
f977 .. 00		type_check_ok_msg:   db " (OK)\r\n", 0 
f97f .. 00		type_check_fail_msg: db " FAIL! :(\r\n", 0 
f98b .. 00		erasewarn_msg:      db "Erase RAM disk starting at page ", 0 
f9ac .. 00		readwarn1_msg:      db "Read RAM disk starting at page ", 0 
f9cc .. 00		readwarn2_msg:      db " from flash page ", 0 
f9de .. 00		writewarn1_msg:     db "Write RAM disk starting at page ", 0 
f9ff .. 00		writewarn2_msg:     db " to flash page ", 0 
fa0f .. 00		genwarn_msg:        db " (y/n)?", 0 
fa17 .. 00		verifybad_msg:      db "Flash write verify failed :(\r\n", 0 
fa36 ..			help_msg:           db "Commands:\r\n" 
fa41 ..			                    db "\tdm addr [len]\t\t\tdisplay memory contents from addr for len (default 1) bytes\r\n" 
fa8f ..			                    db "\twm addr val [val...]\t\twrite bytes to memory starting at addr\r\n" 
face ..			                    db "\tcp src dst len\t\t\tcopy len bytes from src to dst\r\n" 
fb00 ..			                    db "\trun addr\t\t\trun code at addr\r\n" 
fb1e ..			                    db "\tin addr\t\t\t\tread I/O port at addr, display result\r\n" 
fb51 ..			                    db "\tout addr val [val...]\t\twrite I/O port at addr with val\r\n" 
fb8a ..			                    db "\tmmu\t\t\t\tshow MMU state\r\n" 
fba2 ..			                    db "\tsp [addr]\t\t\tshow stack pointer (and set to addr)\r\n" 
fbd5 ..			                    db "\tbuf [addr]\t\t\tshow input buffer (and set to addr)\r\n" 
fc08 ..			                    db "\trboot page\t\t\tBoot from RAM disk\r\n" 
fc2a ..			                    db "\trerase [page]\t\t\tErase RAM disk\r\n" 
fc4b ..			                    db "\trread [page] [flashpage]\tRead RAM disk from SPI flash\r\n" 
fc83 ..			                    db "\trwrite [page] [flashpage]\tWrite RAM disk to SPI flash\r\n" 
fcbb ..			                    db "\t@[cmd]\t\t\t\tPerform command without echo or terminal handling (bulk operations)\r\n" 
fd0b 00			                    db 0 
fd0c .. 00		cmd_rboot:          db "rboot ", 0 
fd13 .. 00		cmd_buf:            db "buf", 0   ; no space at end (arg is optional) 
fd17 .. 00		cmd_cp:             db "cp ", 0 
fd1b .. 00		cmd_dm:             db "dm ", 0 
fd1f .. 00		cmd_help:           db "help", 0 
fd24 .. 00		cmd_help2:          db "?", 0 
fd26 .. 00		cmd_in:             db "in ", 0 
fd2a .. 00		cmd_mmu:            db "mmu",0 
fd2e .. 00		cmd_out:            db "out ", 0 
fd33 .. 00		cmd_run:            db "run ", 0 
fd38 .. 00		cmd_sp:             db "sp",0     ; no space at end (arg is optional) 
fd3b .. 00		cmd_wm:             db "wm ", 0 
fd3f .. 00		cmd_rerase:         db "rerase", 0 
fd46 .. 00		cmd_rread:          db "rread", 0 
fd4c .. 00		cmd_rwrite:         db "rwrite", 0 
fd53			cmd_table:           
fd53 17 fd c5 f2	                    dw cmd_cp, do_cp 
fd57 1b fd 55 f1	                    dw cmd_dm, do_dm 
fd5b 1f fd d8 f0	                    dw cmd_help, do_help 
fd5f 24 fd d8 f0	                    dw cmd_help2, do_help 
fd63 26 fd e1 f0	                    dw cmd_in, do_in 
fd67 2a fd 0c f2	                    dw cmd_mmu, do_mmu 
fd6b 0c fd a4 f1	                    dw cmd_rboot, do_rboot 
fd6f 2e fd 09 f1	                    dw cmd_out, do_out 
fd73 33 fd 98 f1	                    dw cmd_run, do_run 
fd77 3b fd 2b f1	                    dw cmd_wm, do_wm 
fd7b 38 fd e2 f2	                    dw cmd_sp, do_sp 
fd7f 13 fd 03 f3	                    dw cmd_buf, do_buf 
fd83 3f fd 23 f3	                    dw cmd_rerase, do_rerase 
fd87 46 fd a9 f3	                    dw cmd_rread, do_rread 
fd8b 4c fd 5f f4	                    dw cmd_rwrite, do_rwrite 
fd8f 00 00		                    dw 0 ; terminate command table 
fd91			 
fd91			; pad to 4K 
fd91 0xfe...		                    ds 0x10000 - $, 0xfe  ; this will be negative when the ROM exceeds 4K so the assembler will alert us to our excess. 
# End of file ./monitor.asm
0000
